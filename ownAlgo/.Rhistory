eval <- left_join(evalDf[remove_ind,], temp, by = "timestampMs")%>%
mutate( distA = raster::pointDistance(p1 = as.matrix(cbind(x_v.y,y_v.y)), p2 = as.matrix(cbind(x,y)),lonlat = F ))
eval
temp<- rbind(objLog %>% select(lon,lat), data %>% select(lon,lat))
temp <- cbind(objLog,as.data.frame(LatLong2XY(temp$lat, temp$lon))[1:nrow(objLog),])
temp<- temp %>% thicken("5 min", "thick5") %>% mutate(timestampMs = as.numeric(thick5))
eval <- left_join(evalDf[remove_ind,], temp, by = "timestampMs")%>%
mutate( distObj = raster::pointDistance(p1 = as.matrix(cbind(x_v.y,y_v.y)), p2 = as.matrix(cbind(x,y)),lonlat = F ))
eval
summary(eval)
# load auxiliary functions
source("../../thesis/scripts/auxFuns.R")
# Full Palmius Script Results
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
file.sources <- list.files(c("functions"),
pattern="*.R$", full.names=TRUE,
ignore.case=TRUE)
sapply(file.sources,source,.GlobalEnv)
# palmius
Sys.time()
dataExample <- select(fin,time,lat,lon,accuracy,nextMeas) %>%
arrange(time) %>%
mutate( nextLon = lead(lon),
nextLat = lead(lat),
index = 1:length(lat),
nextTimeSec = nextMeas
) %>%
as_tbl_time(time) %>%
filter_time( ~ '2017-03')
filtered<- filteringPalmius(data = dataExample) #no unique locations removed
downsampled <-  downSamplingPalmius(data = filtered) #change name of time column, lat and lon
remove_ind
downsampledPalmius
downsampled
downsampledIan
downsampled %>% pull(time) %>% as.numeric()
downsampled %>% pull(time_5min) %>% as.numeric()
downsampled %>% pull(time_5min) %>% as.numeric()==downsampledIan$timestampMs
downsampledObjPalmius<- downsampled
downsampledObjPalmius[remove_ind,c("lonF","latF")] <- NA
interval <- 300
preImp<- featureExtractPalmius(downsampledObjPalmius) #extract features for imputation
imputedP<- palmiusImputeLoop(preImp) # get imputation
preimp
preImp
debug(palmiusImputeLoop)
imputedP<- palmiusImputeLoop(preImp) # get imputation
imputedP<- palmiusImputeLoop(preImp) # get imputation
undebug(palmiusImputeLoop)
palmiusImputeLoop <- function(inputDF){
timeNow <- Sys.time()
indxFirstMissing<- which(inputDF$firstMissing == 1)
inputDF$impLon <- NA
inputDF$impLat <- NA
inputDF$impType <- NA
mismatch <- 0
mismatchList <- list()
for(i in indxFirstMissing){
cat(i)
data<- inputDF[i,]
# extract variables
tMissEnd<- data["tMissEnd"]
tMissStart<- data["tMissStart"]
#distance to end etc
distEndHome <- data["distEndHome"]
distStartHome <- data["distStartHome"]
#location missing end and beginning
locMissEnd<- data[c("lonMissEnd", "latMissEnd")]
locMissStart<- data[c("lonMissStart", "latMissStart")]
#Hour in PM needed
hour24 <- data["hour24"]
delta_dist <- data["delta_dist"]
# Calculate time elapsed
delta_t <- tMissEnd - tMissStart
# length of missing intervals
lengthMiss <- (delta_t/interval)-1
# Calculate midpoints
midpoint <- colMeans(rbind(locMissStart,setNames(locMissEnd, names(locMissStart))))
#impute
imputed <- imputePalmiusA1(distEndHome = distEndHome,
distStartHome = distStartHome,
delta_t = delta_t,
hour24 = hour24,
locMissStart = locMissStart,
locMissEnd = locMissEnd,
del
ta_dist = delta_dist,
midpoint = midpoint)
inputDF[(i:as.numeric(i+lengthMiss-1)),"impType"] <- imputed[[2]]
imputed <- imputed[[1]]
#end result for loop
#NA breaks it
if(is.na(imputed)){next}
if(dim(imputed)!= dim(inputDF[i:as.numeric(i+lengthMiss-1),c("impLon","impLat")])){
cat(paste0("dimension mismatch \n"))
mismatch <- mismatch + 1
mismatchList[mismatch] <- nrow(imputed)-length(i:as.numeric(i+lengthMiss-1))
imputed <- matrix(colMeans(imputed),ncol = 2)
}
inputDF[i:as.numeric(i+lengthMiss-1),c("impLon")] <- imputed[,1]
inputDF[i:as.numeric(i+lengthMiss-1),c("impLat")] <- imputed[,2]
print(inputDF[i:as.numeric(i+lengthMiss-1),c("impLon","impLat")])
}
timeEnd <- Sys.time()
cat(paste0("Started ",timeNow," finished ",timeEnd,"\n the mismatch is :",mismatch," times\n mean mismatch of ", mean(unlist(mismatchList))))
return(inputDF)
}
palmiusImputeLoop <- function(inputDF){
timeNow <- Sys.time()
indxFirstMissing<- which(inputDF$firstMissing == 1)
inputDF$impLon <- NA
inputDF$impLat <- NA
inputDF$impType <- NA
mismatch <- 0
mismatchList <- list()
for(i in indxFirstMissing){
cat(i)
data<- inputDF[i,]
# extract variables
tMissEnd<- data["tMissEnd"]
tMissStart<- data["tMissStart"]
#distance to end etc
distEndHome <- data["distEndHome"]
distStartHome <- data["distStartHome"]
#location missing end and beginning
locMissEnd<- data[c("lonMissEnd", "latMissEnd")]
locMissStart<- data[c("lonMissStart", "latMissStart")]
#Hour in PM needed
hour24 <- data["hour24"]
delta_dist <- data["delta_dist"]
# Calculate time elapsed
delta_t <- tMissEnd - tMissStart
# length of missing intervals
lengthMiss <- (delta_t/interval)-1
# Calculate midpoints
midpoint <- colMeans(rbind(locMissStart,setNames(locMissEnd, names(locMissStart))))
#impute
imputed <- imputePalmiusA1(distEndHome = distEndHome,
distStartHome = distStartHome,
delta_t = delta_t,
hour24 = hour24,
locMissStart = locMissStart,
locMissEnd = locMissEnd,
del
ta_dist = delta_dist,
midpoint = midpoint)
inputDF[(i:as.numeric(i+lengthMiss-1)),"impType"] <- imputed[[2]]
imputed <- imputed[[1]]
#end result for loop
#NA breaks it
if(is.na(imputed)){next}
if(dim(imputed)!= dim(inputDF[i:as.numeric(i+lengthMiss-1),c("impLon","impLat")])){
cat(paste0("dimension mismatch \n"))
mismatch <- mismatch + 1
mismatchList[mismatch] <- nrow(imputed)-length(i:as.numeric(i+lengthMiss-1))
imputed <- matrix(colMeans(imputed),ncol = 2)
}
inputDF[i:as.numeric(i+lengthMiss-1),c("impLon")] <- imputed[,1]
inputDF[i:as.numeric(i+lengthMiss-1),c("impLat")] <- imputed[,2]
print(inputDF[i:as.numeric(i+lengthMiss-1),c("impLon","impLat")])
}
timeEnd <- Sys.time()
cat(paste0("Started ",timeNow," finished ",timeEnd,"\n the mismatch is :",mismatch," times\n mean mismatch of ", mean(unlist(mismatchList))))
return(inputDF)
}
palmiusImputeLoop <- function(inputDF){
timeNow <- Sys.time()
indxFirstMissing<- which(inputDF$firstMissing == 1)
inputDF$impLon <- NA
inputDF$impLat <- NA
inputDF$impType <- NA
mismatch <- 0
mismatchList <- list()
for(i in indxFirstMissing){
cat(i)
data<- inputDF[i,]
# extract variables
tMissEnd<- data["tMissEnd"]
tMissStart<- data["tMissStart"]
#distance to end etc
distEndHome <- data["distEndHome"]
distStartHome <- data["distStartHome"]
#location missing end and beginning
locMissEnd<- data[c("lonMissEnd", "latMissEnd")]
locMissStart<- data[c("lonMissStart", "latMissStart")]
#Hour in PM needed
hour24 <- data["hour24"]
delta_dist <- data["delta_dist"]
# Calculate time elapsed
delta_t <- tMissEnd - tMissStart
# length of missing intervals
lengthMiss <- (delta_t/interval)-1
# Calculate midpoints
midpoint <- colMeans(rbind(locMissStart,setNames(locMissEnd, names(locMissStart))))
#impute
imputed <- imputePalmiusA1(distEndHome = distEndHome,
distStartHome = distStartHome,
delta_t = delta_t,
hour24 = hour24,
locMissStart = locMissStart,
locMissEnd = locMissEnd,
del
ta_dist = delta_dist,
midpoint = midpoint)
inputDF[(i:as.numeric(i+lengthMiss-1)),"impType"] <- imputed[[2]]
imputed <- imputed[[1]]
#end result for loop
#NA breaks it
if(is.na(imputed)){next}
if(dim(imputed)!= dim(inputDF[i:as.numeric(i+lengthMiss-1),c("impLon","impLat")])){
cat(paste0("dimension mismatch \n"))
mismatch <- mismatch + 1
mismatchList[mismatch] <- nrow(imputed)-length(i:as.numeric(i+lengthMiss-1))
imputed <- matrix(colMeans(imputed),ncol = 2)
}
inputDF[i:as.numeric(i+lengthMiss-1),c("impLon")] <- imputed[,1]
inputDF[i:as.numeric(i+lengthMiss-1),c("impLat")] <- imputed[,2]
print(inputDF[i:as.numeric(i+lengthMiss-1),c("impLon","impLat")])
}
timeEnd <- Sys.time()
cat(paste0("Started ",timeNow," finished ",timeEnd,"\n the mismatch is :",mismatch," times\n mean mismatch of ", mean(unlist(mismatchList))))
return(inputDF)
}
palmiusImputeLoop <- function(inputDF){
timeNow <- Sys.time()
indxFirstMissing<- which(inputDF$firstMissing == 1)
inputDF$impLon <- NA
inputDF$impLat <- NA
inputDF$impType <- NA
mismatch <- 0
mismatchList <- list()
for(i in indxFirstMissing){
cat(i)
data<- inputDF[i,]
# extract variables
tMissEnd<- data["tMissEnd"]
tMissStart<- data["tMissStart"]
#distance to end etc
distEndHome <- data["distEndHome"]
distStartHome <- data["distStartHome"]
#location missing end and beginning
locMissEnd<- data[c("lonMissEnd", "latMissEnd")]
locMissStart<- data[c("lonMissStart", "latMissStart")]
#Hour in PM needed
hour24 <- data["hour24"]
delta_dist <- data["delta_dist"]
# Calculate time elapsed
delta_t <- tMissEnd - tMissStart
# length of missing intervals
lengthMiss <- (delta_t/interval)-1
# Calculate midpoints
midpoint <- colMeans(rbind(locMissStart,setNames(locMissEnd, names(locMissStart))))
#impute
imputed <- imputePalmiusA1(distEndHome = distEndHome,
distStartHome = distStartHome,
delta_t = delta_t,
hour24 = hour24,
locMissStart = locMissStart,
locMissEnd = locMissEnd,
delta_dist = delta_dist,
midpoint = midpoint)
inputDF[(i:as.numeric(i+lengthMiss-1)),"impType"] <- imputed[[2]]
imputed <- imputed[[1]]
#end result for loop
#NA breaks it
if(is.na(imputed)){next}
if(dim(imputed)!= dim(inputDF[i:as.numeric(i+lengthMiss-1),c("impLon","impLat")])){
cat(paste0("dimension mismatch \n"))
mismatch <- mismatch + 1
mismatchList[mismatch] <- nrow(imputed)-length(i:as.numeric(i+lengthMiss-1))
imputed <- matrix(colMeans(imputed),ncol = 2)
}
inputDF[i:as.numeric(i+lengthMiss-1),c("impLon")] <- imputed[,1]
inputDF[i:as.numeric(i+lengthMiss-1),c("impLat")] <- imputed[,2]
print(inputDF[i:as.numeric(i+lengthMiss-1),c("impLon","impLat")])
}
timeEnd <- Sys.time()
cat(paste0("Started ",timeNow," finished ",timeEnd,"\n the mismatch is :",mismatch," times\n mean mismatch of ", mean(unlist(mismatchList))))
return(inputDF)
}
calcImputeDist(imputedP,remove_ind,downsampled = downsampled) #median 0, mean 43
imputedP<- palmiusImputeLoop(preImp) # get imputation
debug(palmiusImputeLoop)
imputedP<- palmiusImputeLoop(preImp) # get imputation
i
i <- 644
data
View(data)
tMissEnd
tMissStart
distEndHome
locMissEnd
locMissStart
debug(imputeFromHome)
undebug(palmiusImputeLoop)
imputedP<- palmiusImputeLoop(preImp) # get imputation
distEndHome
tMissEnd
tMissEnd
# Palmius Algorithm A1
imputePalmiusA1 <- function(distEndHome = distEndHome,
distStartHome = distStartHome,
delta_t = delta_t,
hour24 = hour24,
locMissStart = locMissStart,
locMissEnd = locMissEnd,
delta_dist = delta_dist,
midpoint = midpoint){
# prior functions to massage the data before
imp <- NA
type <- "None"
if (delta_dist < 1000 & (delta_t <= 6*60*60 | (hour24 >= 21 & delta_t <= 12 * 60 * 60))) {
cat("Midpoint interpolation 1 \n")
imp <- imputeMidpointPalmius(tMissStart = tMissStart,
tMissEnd = tMissEnd,
locMissStart = locMissStart,
locMissEnd = locMissEnd,
midpoint = midpoint,
delta_t = delta_t)
type <- "Midpoint Imputatation 1"
} else if (distStartHome < 750 & distEndHome < 750 & (hour24 > 21 & delta_t <= 18 * 60 * 60)) {
cat("Midpoint interpolation 2 \n")
imp <- imputeMidpointPalmius(tMissStart = tMissStart,
tMissEnd = tMissEnd,
locMissStart = locMissStart,
locMissEnd = locMissEnd,
midpoint = midpoint,
delta_t = delta_t)
type <- "Midpoint Imputatation 2"
} else if (distStartHome < 250 & distEndHome < 250 & (hour24 >= 21 & delta_t <= 18 * 60 * 60)) {
cat("Midpoint interpolation 3 \n")
imp <- imputeMidpointPalmius(tMissStart = tMissStart,
tMissEnd = tMissEnd,
locMissStart = locMissStart,
locMissEnd = locMissEnd,
midpoint = midpoint,
delta_t = delta_t)
type <- "Midpoint Imputatation 3"
} else if (distStartHome > 750 & distEndHome < 750 & (delta_t < 6 * 60 * 60 | (hour24 >= 20 & delta_t <= 18 * 60 * 60))) {
cat("To Home interpolation \n")
imp <- imputeToHome(tMissStart = tMissStart,
tMissEnd = tMissEnd,
locMissStart = locMissStart,
locMissEnd = locMissEnd,
delta_t = delta_t,
distStartHome = distStartHome)
type <- "toHomeImputatation 1"
} else if (distStartHome < 750 & distEndHome > 750 & (delta_t < 6 * 60 * 60 | (hour24 >= 20 & delta_t <= 18 * 60 * 60))) {
cat("From Home interpolation \n")
imp <- imputeFromHome(tMissStart = tMissStart,
tMissEnd = tMissEnd,
locMissStart = locMissStart,
locMissEnd   = locMissEnd,
delta_t = delta_t,
distEndHome = distEndHome)
type <- "From HommeImputatation 2"
}
result<- list(imp,type)
return(result)
}
undebug(imputeFromHome)
imputedP<- palmiusImputeLoop(preImp) # get imputation
palmiusImputeLoop <- function(inputDF){
timeNow <- Sys.time()
indxFirstMissing<- which(inputDF$firstMissing == 1)
inputDF$impLon <- NA
inputDF$impLat <- NA
inputDF$impType <- NA
mismatch <- 0
mismatchList <- list()
for(i in indxFirstMissing){
cat(i)
data<- inputDF[i,]
# extract variables
tMissEnd<- data["tMissEnd"]
tMissStart<- data["tMissStart"]
#distance to end etc
distEndHome <- data["distEndHome"]
distStartHome <- data["distStartHome"]
#location missing end and beginning
locMissEnd<- data[c("lonMissEnd", "latMissEnd")]
locMissStart<- data[c("lonMissStart", "latMissStart")]
#Hour in PM needed
hour24 <- data["hour24"]
delta_dist <- data["delta_dist"]
# Calculate time elapsed
delta_t <- tMissEnd - tMissStart
# length of missing intervals
lengthMiss <- (delta_t/interval)-1
# Calculate midpoints
midpoint <- colMeans(rbind(locMissStart,setNames(locMissEnd, names(locMissStart))))
#impute
imputed <- imputePalmiusA1(distEndHome = distEndHome,
distStartHome = distStartHome,
delta_t = delta_t,
hour24 = hour24,
locMissStart = locMissStart,
locMissEnd = locMissEnd,
delta_dist = delta_dist,
midpoint = midpoint,
tMissEnd = tMissEnd,
tMissStart = tMissStart)
inputDF[(i:as.numeric(i+lengthMiss-1)),"impType"] <- imputed[[2]]
imputed <- imputed[[1]]
#end result for loop
#NA breaks it
if(is.na(imputed)){next}
if(dim(imputed)!= dim(inputDF[i:as.numeric(i+lengthMiss-1),c("impLon","impLat")])){
cat(paste0("dimension mismatch \n"))
mismatch <- mismatch + 1
mismatchList[mismatch] <- nrow(imputed)-length(i:as.numeric(i+lengthMiss-1))
imputed <- matrix(colMeans(imputed),ncol = 2)
}
inputDF[i:as.numeric(i+lengthMiss-1),c("impLon")] <- imputed[,1]
inputDF[i:as.numeric(i+lengthMiss-1),c("impLat")] <- imputed[,2]
print(inputDF[i:as.numeric(i+lengthMiss-1),c("impLon","impLat")])
}
timeEnd <- Sys.time()
cat(paste0("Started ",timeNow," finished ",timeEnd,"\n the mismatch is :",mismatch," times\n mean mismatch of ", mean(unlist(mismatchList))))
return(inputDF)
}
imputedP<- palmiusImputeLoop(preImp) # get imputation
# Palmius Algorithm A1
imputePalmiusA1 <- function(distEndHome = distEndHome,
distStartHome = distStartHome,
delta_t = delta_t,
hour24 = hour24,
locMissStart = locMissStart,
locMissEnd = locMissEnd,
delta_dist = delta_dist,
midpoint = midpoint,
tMissEnd = tMissEnd,
tMissStart = tMissStart){
# prior functions to massage the data before
imp <- NA
type <- "None"
if (delta_dist < 1000 & (delta_t <= 6*60*60 | (hour24 >= 21 & delta_t <= 12 * 60 * 60))) {
cat("Midpoint interpolation 1 \n")
imp <- imputeMidpointPalmius(tMissStart = tMissStart,
tMissEnd = tMissEnd,
locMissStart = locMissStart,
locMissEnd = locMissEnd,
midpoint = midpoint,
delta_t = delta_t)
type <- "Midpoint Imputatation 1"
} else if (distStartHome < 750 & distEndHome < 750 & (hour24 > 21 & delta_t <= 18 * 60 * 60)) {
cat("Midpoint interpolation 2 \n")
imp <- imputeMidpointPalmius(tMissStart = tMissStart,
tMissEnd = tMissEnd,
locMissStart = locMissStart,
locMissEnd = locMissEnd,
midpoint = midpoint,
delta_t = delta_t)
type <- "Midpoint Imputatation 2"
} else if (distStartHome < 250 & distEndHome < 250 & (hour24 >= 21 & delta_t <= 18 * 60 * 60)) {
cat("Midpoint interpolation 3 \n")
imp <- imputeMidpointPalmius(tMissStart = tMissStart,
tMissEnd = tMissEnd,
locMissStart = locMissStart,
locMissEnd = locMissEnd,
midpoint = midpoint,
delta_t = delta_t)
type <- "Midpoint Imputatation 3"
} else if (distStartHome > 750 & distEndHome < 750 & (delta_t < 6 * 60 * 60 | (hour24 >= 20 & delta_t <= 18 * 60 * 60))) {
cat("To Home interpolation \n")
imp <- imputeToHome(tMissStart = tMissStart,
tMissEnd = tMissEnd,
locMissStart = locMissStart,
locMissEnd = locMissEnd,
delta_t = delta_t,
distStartHome = distStartHome)
type <- "toHomeImputatation 1"
} else if (distStartHome < 750 & distEndHome > 750 & (delta_t < 6 * 60 * 60 | (hour24 >= 20 & delta_t <= 18 * 60 * 60))) {
cat("From Home interpolation \n")
imp <- imputeFromHome(tMissStart = tMissStart,
tMissEnd = tMissEnd,
locMissStart = locMissStart,
locMissEnd   = locMissEnd,
delta_t = delta_t,
distEndHome = distEndHome)
type <- "From HommeImputatation 2"
}
result<- list(imp,type)
return(result)
}
imputedP<- palmiusImputeLoop(preImp) # get imputation
calcImputeDist(imputedP,remove_ind,downsampled = downsampled) #median 0, mean 43
imputedP
imputedP %>% slice(remove_ind)
imputedP %>% slice(remove_ind) %>% select(impLon,impLat)
imputedP %>% slice(remove_ind) %>% select(timestampMs,impLon,impLat)
objLog
imputedP %>% slice(remove_ind) %>%
select(timestampMs,impLon,impLat) %>%
left_join(., objLog %>%thicken("5 min", "thick5") %>% mutate(timestampMs = as.numeric(thick5)), by = timestampMs)
imputedP %>% slice(remove_ind) %>%
select(timestampMs,impLon,impLat) %>%
left_join(., objLog %>%thicken("5 min", "thick5") %>% mutate(timestampMs = as.numeric(thick5)), by = "timestampMs")
imputedP %>% slice(remove_ind) %>%
select(timestampMs,impLon,impLat) %>%
left_join(., objLog %>%thicken("5 min", "thick5") %>% mutate(timestampMs = as.numeric(thick5)), by = "timestampMs") %>%
mutate( dist = raster::pointDistance(p1 = as.matrix(cbind(impLon,impLat)), p2 = as.matrix(cbind(lon,lat)),lonlat = T ))
imputedP %>% slice(remove_ind) %>%
select(timestampMs,impLon,impLat) %>%
left_join(., objLog %>%thicken("5 min", "thick5") %>% mutate(timestampMs = as.numeric(thick5)), by = "timestampMs") %>%
mutate( dist = raster::pointDistance(p1 = as.matrix(cbind(impLon,impLat)), p2 = as.matrix(cbind(lon,lat)),lonlat = T )) %>%
summary()
(175+280)
(175+280)/500
(175+280+175)/1000
# image creation
install.packages("magick")
